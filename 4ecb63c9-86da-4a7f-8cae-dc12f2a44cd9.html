<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>用 Dataview 批量编辑笔记 - Zji</title>
  <link rel="stylesheet" href="github-markdown.css">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="atom-one-dark.min.css">

</head>
<body>
  <main>
    <article class="markdown-body">
      <h1 class="note-title">用 Dataview 批量编辑笔记</h1>
      <section><h2 id="%E5%BC%95%E5%AD%90">引子</h2><p>Obsidian 好像没有批量查找替换吧，没有吧，没有吧？我懒得深入研究……（真懒</p>
<p>有需求的时候就打开 VS Code，批量查找替换支持正则，很爽啊！</p>
<p>但是这样并不能满足所有需求，毕竟总会有更复杂的情况，比如给某些具有特定标记、特征的笔记进行一些编辑、修改、替换什么的。是的，我可以写个脚本，但是遍历所有文件，分析内容结构啥的，不说难吧，有点麻烦。</p>
<p>而 Dataview 是 Obsidian 下非常强大的查询插件，如果它能在查询之后进行编辑，那就完美了。</p>
<h2 id="%E5%8E%9F%E7%90%86">原理</h2><p>Dataview 本身没有提供对笔记的编辑功能，甚至对于笔记内容的读取功能都没有。它能查询笔记中的各种特征，但不是笔记中的所有内容。这是基于资源开销的考虑，现在这样的设计只需要查询 Obsidian 提供的缓存就可以了。</p>
<p>所以这里需要用到几个 Obsidian 自身的 api：</p>
<ul>
<li><code>app.vault.readRaw(笔记路径)</code>：这是读取笔记的原始内容，很多用户脚本中会使用，但是<a href="https://docs.obsidian.md/Plugins/Vault" title="官方的 API 文档">官方的 API 文档</a>中并没推荐。异步函数，需要 <code>await</code>。</li><li><a href="https://docs.obsidian.md/Plugins/Vault#Read%20files" title="官方推荐的方法">官方推荐的方法</a>有两种： <code>app.vault.read(文件对象)</code> 和 <code>app.vault.readCache(文件对象)</code>。以下摘抄自官方文档：<ul>
<li>If you only want to display the content to the user, then use <code>cachedRead()</code> to avoid reading the file from disk multiple times.<br>如果只想向用户显示内容，则使用 <code>cachedRead()</code> 以避免多次从磁盘读取文件。</li><li>If you want to read the content, change it, and then write it back to disk, then use <code>read()</code> to avoid potentially overwriting the file with a stale copy.<br>  如果您想要读取内容、更改内容，然后将其写回磁盘，请使用 <code>read()</code> 以避免可能用过时的副本覆盖文件。</li></ul>
</li><li>如何获取参数中的文件对象，方法比较多，最容易发现的是 <code>app.valut.getFiles()</code> 方法，类似的还有 <code>app.valut.getFilesCache()</code> 方法，但这些是一次读取所有文件，所以很多场景下并不适用。毕竟我们已经用 Dataview 去完成了查询和过滤的工作，所以这里没必要再一次读取所有文件并过滤。</li><li><code>app.vault.getAbstractFileByPath(文件路径)</code> 可以获取文件对象，在读写 api 中都会用到</li><li>用 <code>app.vault.modify(文件对象, 新的内容)</code> 方法对笔记进行修改，必须用完整笔记内容去替换掉旧的笔记。</li></ul>
<h2 id="%E5%AE%9E%E8%B7%B5">实践</h2><pre class="hljs js" lang="js"><span class="hljs-comment">/* 首先用 Dataivew 查询所有你需要的页面 */</span>
dv.<span class="hljs-title function_">pages</span>()
<span class="hljs-comment">/* 根据一些条件对页面进行筛选 */</span>
.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">p</span>=&gt;</span>p.<span class="hljs-property">file</span>.<span class="hljs-property">frontmatter</span>.<span class="hljs-property">published</span> &amp;&amp; p.<span class="hljs-property">file</span>.<span class="hljs-property">frontmatter</span>.<span class="hljs-property">title</span>)
<span class="hljs-comment">/* 遍历并修改选出的页面 */</span>
.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">async</span> p=&gt;{
  <span class="hljs-comment">/* 获取当前遍历到的文件对象 */</span>
  <span class="hljs-keyword">const</span> noteTFile = app.<span class="hljs-property">vault</span>.<span class="hljs-title function_">getAbstractFileByPath</span>(p.<span class="hljs-property">file</span>.<span class="hljs-property">path</span>)
  <span class="hljs-comment">/* 读取笔记内容 */</span>
  <span class="hljs-keyword">const</span> noteContent = <span class="hljs-keyword">await</span> app.<span class="hljs-property">vault</span>.<span class="hljs-title function_">read</span>(noteTFile)
  <span class="hljs-comment">/* 根据需求对内容进行加工，获得新的内容 */</span>
  <span class="hljs-keyword">const</span> uuidLine = <span class="hljs-string">`id: <span class="hljs-subst">${crypto.randomUUID()}</span>\n`</span>
  <span class="hljs-keyword">const</span> newContent = noteContent.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(^-{3,}\n)([\s\S]*?-{3,}\n)/g</span>, <span class="hljs-function">(<span class="hljs-params">m, p1, p2</span>)=&gt;</span>p1+uuidLine+p2)
  <span class="hljs-comment">/* 将新内容写回 */</span>
  <span class="hljs-keyword">await</span> app.<span class="hljs-property">vault</span>.<span class="hljs-title function_">modify</span>(noteTFile, newContent)
})</pre><h2 id="%E4%BC%98%E5%8C%96">优化</h2><p>Dataview 的代码会被自动执行，这导致每次显示到该代码块，这套自动编辑的动作都会被做一遍，这很可能产生意外。所以我会把上面的内容定义为一个函数，在代码块中插入一个按钮来触发这个动作，并且在执行时输出一些日志，以便观察执行情况。</p>
<p>这部分我在自己笔记中的 <code>Dataview\Tools\UUID</code> 视图中有完整的应用。</p>
</section>
    </article>
  </main>
  <aside>
    <div class="toggle"><i class="fa-solid fa-bars"></i></div>
    <div class="aside-content">
      <div class="nav">
        <ul>
          <li class="home"><a href="/"><i class="fa-solid fa-house"></i> Home</a></li>
          <li class="meow"><a href="https://afdian.net/a/daomishu" target="_blank"><i class="fa-solid fa-heart"></i> Meow~</a></li>
          <li class="gotop"><a href="#"><i class="fa-solid fa-plane-up"></i> Top</a></li>
        </ul>
      </div>
      <div class="toc"><ul><li data-hash="%E5%BC%95%E5%AD%90" style="margin-left: 1.5em"><a href="#%E5%BC%95%E5%AD%90">引子</a></li>
<li data-hash="%E5%8E%9F%E7%90%86" style="margin-left: 1.5em"><a href="#%E5%8E%9F%E7%90%86">原理</a></li>
<li data-hash="%E5%AE%9E%E8%B7%B5" style="margin-left: 1.5em"><a href="#%E5%AE%9E%E8%B7%B5">实践</a></li>
<li data-hash="%E4%BC%98%E5%8C%96" style="margin-left: 1.5em"><a href="#%E4%BC%98%E5%8C%96">优化</a></li></ul></div>
      <div class="meta"><small>created: 2023-11-03 08:58:04</small><br><small>updated: 2023-11-03 09:40:21</small></div>
    </div>
  </aside>
  <script src="script.js"></script>
  <script async
    src="https://state.zji.me/script.js"
    data-website-id="746d3aee-45c2-4dea-b72f-0cfb7891afe3"
    data-do-not-track="true"
    data-domains="zji.me"></script>
  <foot>©2022~2023 稻米鼠. Last build at 2023/11/26 00:00:21</foot>
</body>
</html>